#!/usr/bin/env python3
import sys
from pathlib import Path
from PIL import Image

# --- GNOME prompt (PyGObject / GTK) ---
try:
    import gi  # type: ignore
    gi.require_version('Gtk', '3.0')     # pin GTK 3 for Nautilus envs
    gi.require_version('Notify', '0.7')
    from gi.repository import Gtk, Notify  # type: ignore
except Exception:
    Gtk = None
    Notify = None

EXTENSION = "jpg"
SAVE_FORMAT = "JPEG"

def ask_quality_and_resize_gnome(default_quality=95):
    """
    Returns (quality:int, width:Optional[int], height:Optional[int]) or (None, None, None) on cancel.
    Defaults: quality=95, width=None, height=None.
    """
    if Gtk is None:
        # TTY fallback with defaults
        try:
            q = input(f"JPEG quality [1-100] (default {default_quality}): ").strip()
            quality = int(q) if q.isdigit() and 1 <= int(q) <= 100 else default_quality
        except Exception:
            quality = default_quality

        w_in = input("Resize width (px, blank = keep): ").strip()
        h_in = input("Resize height (px, blank = keep): ").strip()

        width = int(w_in) if w_in.isdigit() else None
        height = int(h_in) if h_in.isdigit() else None
        return quality, width, height

    # GTK flow
    if Notify is not None:
        try:
            Notify.init("Image Converter")
        except Exception:
            pass

    dialog = Gtk.Dialog(title="JPEG Options")
    dialog.set_modal(True)
    dialog.add_button("_Cancel", Gtk.ResponseType.CANCEL)
    dialog.add_button("_OK", Gtk.ResponseType.OK)
    dialog.set_default_response(Gtk.ResponseType.OK)

    content = dialog.get_content_area()
    content.set_spacing(8)
    try:
        content.set_border_width(12)
    except Exception:
        pass

    grid = Gtk.Grid()
    grid.set_row_spacing(8)
    grid.set_column_spacing(8)

    # Quality
    q_label = Gtk.Label(label="JPEG quality (1–100):")
    q_label.set_xalign(0.0)
    q_adj = Gtk.Adjustment(value=default_quality, lower=1, upper=100, step_increment=1, page_increment=5, page_size=0)
    q_spin = Gtk.SpinButton()
    q_spin.set_adjustment(q_adj)
    q_spin.set_numeric(True)
    q_spin.set_value(default_quality)

    # Width / Height entries
    w_label = Gtk.Label(label="Width (px, blank = keep):")
    w_label.set_xalign(0.0)
    w_entry = Gtk.Entry()
    w_entry.set_placeholder_text("Leave blank to keep original width")

    h_label = Gtk.Label(label="Height (px, blank = keep):")
    h_label.set_xalign(0.0)
    h_entry = Gtk.Entry()
    h_entry.set_placeholder_text("Leave blank to keep original height")

    # Hint
    hint = Gtk.Label()
    hint.set_xalign(0.0)
    hint.set_line_wrap(True)
    hint.set_markup(
        "• Leave both blank to skip resizing.\n"
        "• Provide only one value to preserve aspect ratio.\n"
        "• Provide both to force that exact size."
    )

    grid.attach(q_label, 0, 0, 1, 1); grid.attach(q_spin, 1, 0, 1, 1)
    grid.attach(w_label, 0, 1, 1, 1); grid.attach(w_entry, 1, 1, 1, 1)
    grid.attach(h_label, 0, 2, 1, 1); grid.attach(h_entry, 1, 2, 1, 1)
    grid.attach(hint,    0, 3, 2, 1)

    content.add(grid)
    dialog.show_all()

    response = dialog.run()
    quality = int(q_spin.get_value()) if q_spin.get_value_as_int() else default_quality
    w_str = w_entry.get_text().strip()
    h_str = h_entry.get_text().strip()
    dialog.destroy()

    if response != Gtk.ResponseType.OK:
        return None, None, None

    width = int(w_str) if w_str.isdigit() else None
    height = int(h_str) if h_str.isdigit() else None
    return quality, width, height

def to_jpeg_black_bg(im: Image.Image) -> Image.Image:
    if im.mode in ("RGBA", "LA") or (im.mode == "P" and "transparency" in im.info):
        rgba = im.convert("RGBA")
        bg = Image.new("RGBA", rgba.size, (0, 0, 0, 255))
        composited = Image.alpha_composite(bg, rgba)
        return composited.convert("RGB")
    if im.mode != "RGB":
        return im.convert("RGB")
    return im

def compute_target_size(orig_w: int, orig_h: int, req_w, req_h):
    """
    req_w/req_h are Optional[int]. Returns (target_w, target_h) or (orig_w, orig_h) if no resize.
    """
    if not req_w and not req_h:
        return orig_w, orig_h  # no resize

    if req_w and req_h:
        # force exact size
        return max(1, req_w), max(1, req_h)

    if req_w and not req_h:
        # preserve aspect from width
        h = int(round(orig_h * (req_w / float(orig_w))))
        return max(1, req_w), max(1, h)

    if req_h and not req_w:
        # preserve aspect from height
        w = int(round(orig_w * (req_h / float(orig_h))))
        return max(1, w), max(1, req_h)

    return orig_w, orig_h

def process(path: Path, quality: int, req_w, req_h) -> None:
    output = path.with_suffix(f".{EXTENSION}")
    try:
        with Image.open(path) as im:
            if getattr(im, "is_animated", False):
                im.seek(0)

            # Compute target size before converting to RGB
            orig_w, orig_h = im.size
            tgt_w, tgt_h = compute_target_size(orig_w, orig_h, req_w, req_h)
            if (tgt_w, tgt_h) != (orig_w, orig_h):
                im = im.resize((tgt_w, tgt_h), resample=Image.LANCZOS) #type: ignore

            rgb = to_jpeg_black_bg(im)

            exif = im.info.get("exif")
            icc = im.info.get("icc_profile")

            save_kwargs = {
                "quality": quality,
                "optimize": True,
                "progressive": True,
            }
            if exif:
                save_kwargs["exif"] = exif
            if icc:
                save_kwargs["icc_profile"] = icc

            rgb.save(output, SAVE_FORMAT, **save_kwargs)

        resized_note = f", resized to {tgt_w}x{tgt_h}" if (tgt_w, tgt_h) != (orig_w, orig_h) else ""
        print(f"Converted {path} -> {output} (quality={quality}{resized_note})")
    except Exception as e:
        print(f"Failed to convert {path} or not a supported format: {e}")

def main():
    if len(sys.argv) < 2:
        print("Usage: convert.py <files...>")
        sys.exit(1)

    quality, width, height = ask_quality_and_resize_gnome(default_quality=95)
    if quality is None:
        print("Cancelled by user.")
        sys.exit(0)

    for arg in sys.argv[1:]:
        process(Path(arg), quality, width, height)

    if Notify is not None:
        try:
            size_msg = "original size" if (not width and not height) else (
                f"{width or 'auto'}×{height or 'auto'}"
            )
            n = Notify.Notification.new("Conversion complete", f"Quality: {quality}, Size: {size_msg}", "image-x-generic")
            n.show()
        except Exception:
            pass

if __name__ == "__main__":
    main()
