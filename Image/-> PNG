#!/usr/bin/env python3
import sys
from pathlib import Path
from PIL import Image

# --- GNOME prompt (PyGObject / GTK) ---
try:
    import gi  # type: ignore
    gi.require_version('Gtk', '3.0')     # pin GTK 3 for Nautilus envs
    gi.require_version('Notify', '0.7')
    from gi.repository import Gtk, Notify  # type: ignore
except Exception:
    Gtk = None
    Notify = None

EXTENSION = "png"
SAVE_FORMAT = "PNG"

def ask_compress_and_resize_gnome(default_compress=6):
    """
    Returns (compress_level:int[0-9], width:Optional[int], height:Optional[int]) or (None, None, None) on cancel.
    Defaults: compress_level=6, width=None, height=None.
    """
    if Gtk is None:
        # TTY fallback with defaults
        try:
            c = input(f"PNG compression level [0-9] (0=fast/large, 9=slow/small, default {default_compress}): ").strip()
            compress = int(c) if c.isdigit() and 0 <= int(c) <= 9 else default_compress
        except Exception:
            compress = default_compress

        w_in = input("Resize width (px, blank = keep): ").strip()
        h_in = input("Resize height (px, blank = keep): ").strip()

        width = int(w_in) if w_in.isdigit() else None
        height = int(h_in) if h_in.isdigit() else None
        return compress, width, height

    # GTK flow
    if Notify is not None:
        try:
            Notify.init("Image Converter")
        except Exception:
            pass

    dialog = Gtk.Dialog(title="PNG Options")
    dialog.set_modal(True)
    dialog.add_button("_Cancel", Gtk.ResponseType.CANCEL)
    dialog.add_button("_OK", Gtk.ResponseType.OK)
    dialog.set_default_response(Gtk.ResponseType.OK)

    content = dialog.get_content_area()
    content.set_spacing(8)
    try:
        content.set_border_width(12)
    except Exception:
        pass

    grid = Gtk.Grid()
    grid.set_row_spacing(8)
    grid.set_column_spacing(8)

    # Compression level
    c_label = Gtk.Label(label="PNG compression (0–9):")
    c_label.set_xalign(0.0)
    c_adj = Gtk.Adjustment(value=default_compress, lower=0, upper=9, step_increment=1, page_increment=1, page_size=0)
    c_spin = Gtk.SpinButton()
    c_spin.set_adjustment(c_adj)
    c_spin.set_numeric(True)
    c_spin.set_value(default_compress)

    # Width / Height entries
    w_label = Gtk.Label(label="Width (px, blank = keep):")
    w_label.set_xalign(0.0)
    w_entry = Gtk.Entry()
    w_entry.set_placeholder_text("Leave blank to keep original width")

    h_label = Gtk.Label(label="Height (px, blank = keep):")
    h_label.set_xalign(0.0)
    h_entry = Gtk.Entry()
    h_entry.set_placeholder_text("Leave blank to keep original height")

    # Hint
    hint = Gtk.Label()
    hint.set_xalign(0.0)
    hint.set_line_wrap(True)
    hint.set_markup(
        "• Leave both blank to skip resizing.\n"
        "• Provide only one value to preserve aspect ratio.\n"
        "• Provide both to force that exact size.\n"
        "• Compression: 0 = fastest/larger file, 9 = slowest/smallest file."
    )

    grid.attach(c_label, 0, 0, 1, 1); grid.attach(c_spin, 1, 0, 1, 1)
    grid.attach(w_label, 0, 1, 1, 1); grid.attach(w_entry, 1, 1, 1, 1)
    grid.attach(h_label, 0, 2, 1, 1); grid.attach(h_entry, 1, 2, 1, 1)
    grid.attach(hint,    0, 3, 2, 1)

    content.add(grid)
    dialog.show_all()

    response = dialog.run()
    compress = int(c_spin.get_value()) if c_spin.get_value_as_int() is not None else default_compress
    w_str = w_entry.get_text().strip()
    h_str = h_entry.get_text().strip()
    dialog.destroy()

    if response != Gtk.ResponseType.OK:
        return None, None, None

    width = int(w_str) if w_str.isdigit() else None
    height = int(h_str) if h_str.isdigit() else None
    return compress, width, height

def compute_target_size(orig_w: int, orig_h: int, req_w, req_h):
    """
    req_w/req_h are Optional[int]. Returns (target_w, target_h) or (orig_w, orig_h) if no resize.
    """
    if not req_w and not req_h:
        return orig_w, orig_h  # no resize

    if req_w and req_h:
        # force exact size
        return max(1, req_w), max(1, req_h)

    if req_w and not req_h:
        # preserve aspect from width
        h = int(round(orig_h * (req_w / float(orig_w))))
        return max(1, req_w), max(1, h)

    if req_h and not req_w:
        # preserve aspect from height
        w = int(round(orig_w * (req_h / float(orig_h))))
        return max(1, w), max(1, req_h)

    return orig_w, orig_h

def prepare_for_resize(im: Image.Image) -> Image.Image:
    """
    Convert to a good working mode for high-quality resampling while preserving transparency when present.
    """
    if im.mode in ("RGBA", "LA"):
        return im
    if im.mode == "P":
        # If palette image has transparency, keep alpha; else RGB is fine
        if "transparency" in im.info:
            return im.convert("RGBA")
        return im.convert("RGB")
    if im.mode in ("1",):
        return im.convert("RGBA")
    return im  # RGB, L, etc.

def process(path: Path, compress_level: int, req_w, req_h) -> None:
    output = path.with_suffix(f".{EXTENSION}")
    try:
        with Image.open(path) as im:
            if getattr(im, "is_animated", False):
                im.seek(0)

            orig_w, orig_h = im.size
            tgt_w, tgt_h = compute_target_size(orig_w, orig_h, req_w, req_h)

            work = im
            if (tgt_w, tgt_h) != (orig_w, orig_h):
                work = prepare_for_resize(work)
                work = work.resize((tgt_w, tgt_h), resample=Image.LANCZOS)  # type: ignore

            # PNG preserves transparency; keep working mode as-is
            icc = im.info.get("icc_profile")  # carry over if present

            save_kwargs = {
                "compress_level": compress_level,   # 0..9
                "optimize": True,                   # palette/entropy optimizations where applicable
            }
            if icc:
                save_kwargs["icc_profile"] = icc

            work.save(output, SAVE_FORMAT, **save_kwargs)

        resized_note = f", resized to {tgt_w}x{tgt_h}" if (tgt_w, tgt_h) != (orig_w, orig_h) else ""
        print(f"Converted {path} -> {output} (compress_level={compress_level}{resized_note})")
    except Exception as e:
        print(f"Failed to convert {path} or not a supported format: {e}")

def main():
    if len(sys.argv) < 2:
        print("Usage: convert_png.py <files...>")
        sys.exit(1)

    compress_level, width, height = ask_compress_and_resize_gnome(default_compress=6)
    if compress_level is None:
        print("Cancelled by user.")
        sys.exit(0)

    for arg in sys.argv[1:]:
        process(Path(arg), compress_level, width, height)

    if Notify is not None:
        try:
            size_msg = "original size" if (not width and not height) else (
                f"{width or 'auto'}x{height or 'auto'}"
            )
            n = Notify.Notification.new(
                "Conversion complete",
                f"Compression: {compress_level}, Size: {size_msg}",
                "image-x-generic"
            )
            n.show()
        except Exception:
            pass

if __name__ == "__main__":
    main()
